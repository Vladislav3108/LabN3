## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2401`

#### Выполнил: `Тараканов Владислав Алексеевич`

#### Вариант: `27`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Выбор структуры данных](#2-выбор-структуры-данных)
- [Алгоритм](#3-алгоритм)
- [Программа](#4-программа)
- [Анализ правильности решения](#5-анализ-правильности-решения)

### 1. Постановка задачи

Разработать программу для реализации системы поиска страниц по ключевым словам.
Каждая страница содержит название, массив слов-ассоциаций и счётчик посещений.
Реализовать функции добавления страниц, выполнения поиска, анализа данных и сортировки страниц по заданным критериям.

Данную задачу можно разделить подзадачи:
1.  Создадим класс страница, хранящий название страницы, список слов-ассоциаций и количество посещений.
2.  Создадим методы для работы со страницей, в том числе вывод в формате: название - количество посещений.
3.  Создадим класс для поиска, вывода и сортировки страниц.
4.  Организуем вывод списка страниц.
5.  Организуем добавление страницы
6.  Организуем вывод слов-ассоциаций нужной страницы.
7.  Организуем вывод списка страниц без слов для поиска.
8.  Организуем увелечение количества посещений для страниц с максимальным количеством слов-ассоциаций.
9.  Организуем увелечение количество посещений для страниц с совпадением четности букв и слов.
10. Организуем поиск и вывод первой страницы с самым длинным словом-ассоциацией.
11. Организуем поиск и увелечение счетчика посещений самой подходящей страницы для запроса.
12. Организуем поиск, вывод и увелечение счетчика посещений для 3-х самых посещаемых страниц.
13. Организуем поиск и вывод страниц наименее подходящих запросу.


### 2. Выбор структуры данных

|       | название переменной |  Тип (в Java)  | Применение      
|-------|---------------------|----------------|------------------------------------------------------
| Число | `title`             | `String`       |название страницы     
| Число | `keywords`          | `List<String>` |список слов-ассоциаций
| Число | `visits`            | `int`          |количество посещений|
| Число | `pages`             | `List<String>` | список всех страниц                
| Число | `maxKeywords`       | `int`          |максимальное количество слов-ассоциаций
| Число | `wordCount`         | `int`          |количество слов-ассоциаций текущей страницы
| Число | `allMatch`          | `boolean`      |соответствие условию четности
| Число | `result`            | `Page`         |страница с самым длинным словом-ассоциацией
| Число | `longestWord`       | `String`       |хранит самое длинное слово
| Число | `word`              | `String`       |перебор всех слов-ассоциаций
| Число | `searchWords`       | `List<String>` |массив для поиска нужной страницы(запрос)
| Массив| `bestPage`          | `Page`         |хранит самую подходящую страницу
| Массив| `maxMatches`        | `int`          |максимальное количество совпадений слов-ассоциаций
| Массив| `matches`           | `int`          |количество совпавших слов-ассоциаций
| Массив| `maxMismatch`       | `int`          |максимальное количество несовпадений
| Массив| `leastRelevantPages`| `List<String>` |список наименее подходящих страниц
| Массив| `mismatch`          | `int`          |количество несовпадений
| Массив| `word`              | `String`       |перебор слов

### 3. Алгоритм

#### Алгоритм выполнения программы:

1. **Класс Page**  
   Необходим для хранения информации о страницы в одном месте. Помогает ускорить работу по поиску и обработке данных и упрощает написание программы.
   Обеспечивает необходимые методы работы с данным классом. Позволяет отдельно получать имя страницы, количество посещений страницы, слова-ассоциации,
   а также увеличивать счетчик посещений и выводить страницу в формате: "название" - "количество посещений".
   
3. **Класс SearchSystem**  
   Используется для организации алгоритмов поиска, обработки и вывода данных о страницах. На борту имеет следующие методы:
     - **displayPages** 
       Вывод списка страниц в формате: "название - количество посещений"
     - **addPage** 
       Добавляет страницу с указанным названием и массивом слов-ассоциаций
     - **displayKeywords**
       Выводит массив слов-ассоциаций для страницы с указанным названием. Количество посещений страницы увеличивается.
     - **displayPagesWithoutKeywords**
       Отображает список страниц, у которых нет слов-ассоциаций для поиска. Увеличивает количество посещений для этих страниц.
     - **pagesWithMaxKeywords**
       Выводит список страниц с максимальным количеством слов-ассоциаций в порядке их добавления. Увеличивает количество посещений для
       каждой страницы в списке.
     - **pagesMatchingWordEvenness**
       Проверяет, есть ли в списке страницы, у которых количество букв в каждом словеассоциации совпадает по чётности с общим
       количеством слов. Увеличивает количество посещений для таких страниц.
     - **pageWithLongestWord**
       Находит и выводит первую страницу, содержащую самое длинное слово среди всех слов-ассоциаций, и это слово.
     - **findMostRelevantPage**
       По переданному массиву слов находит и возвращает страницу, которая больше всего подходит. Подходящей
       считается страница с максимальным количеством совпадений слов. Увеличивает количество посещений для найденной страницы.
     - **topThreePages**
       Выводит три самые посещаемые страницы. Если у нескольких страниц одинаковое количество посещений, выводятся первые
       по порядку добавления. Увеличивает количество посещений для этих страниц.
     - **findLeastRelevantPages**
       По переданному массиву слов находит страницы, которые наименее соответствуют массиву. Наименьшее соответствие
       определяется количеством слов, которые есть в одном массиве, но отсутствуют в другом. Возвращает список таких страниц.



### 4. Программа

```java
import java.util.*;

//создание класса Страница
class Page {
    String title;//название страницы
    List<String> keywords;// список слов-ассоциаций
    int visits;//количество просмотров страницы

    //создание конструктора для создания страницы
    public Page(String title, List<String> keywords,Integer visits) {
        this.title = title;
        this.keywords = new ArrayList<>(keywords);
        this.visits = visits;
    }

    //метод для получения имени страницы
    public String getTitle() {
        return title;
    }

    //метод для получения количества посещений страницы
    public int getVisits() {
        return visits;
    }

    //метод для получения слов-ассоциацией страницы
    public List<String> getKeywords() {
        return keywords;
    }

    //метод для увелечения количества посещений страницы на один
    public void incrementVisits() {
        visits++;
    }

    //метод для вывода имени страницы и количества посещений
    @Override
    public String toString() {
        return title + " - " + visits;
    }
}

//создания класса для поиска, вывода и сортировки страниц
class SearchSystem {
    private final List<Page> pages = new ArrayList<>();

    // 1. Вывод списка страниц
    public void displayPages() {
        for (Page page : pages) {
            System.out.println(page);
        }
    }

    // 2. Добавление страницы
    public void addPage(String title, List<String> keywords, Integer visits) {
        pages.add(new Page(title, keywords, visits));
    }

    // 3. Вывод слов-ассоциаций страницы, которую ищем
    public void displayKeywords(String title) {
        for (Page page : pages) {
            if (page.getTitle().equalsIgnoreCase(title)) {//поиск страницы с таким же названием
                page.incrementVisits();//когда нашли нужную страницу, увеличиваем счетчик посещений на один
                System.out.println(page.getKeywords());//выводим слова-ассоциации нужной страницы
                return;
            }
        }
        System.out.println("Page not found.");//Если не нашли страницу с нужным названием выводим, что страница не найдена
    }

    // 4. Вывод страниц без слов для поиска
    public void displayPagesWithoutKeywords() {
        for (Page page : pages) {
            if (page.getKeywords().isEmpty()) {//проверяем пустой ли список слов-ассоциаций
                page.incrementVisits();//увеличиваем счетчик посещений на один
                System.out.println(page);//выводим название страницы и количество посещений
            }
        }
    }

    // 5. Страницы с максимальным количеством слов-ассоциаций
    public void pagesWithMaxKeywords() {//находим максимальное количество слов-ассоциаций
        int maxKeywords = pages.stream()//создаем поток из коллекции pages
                .mapToInt(page -> page.getKeywords().size())//преобразуем каждую страницу в поток чисел,где каждое число количества слов-ассоциаций
                .max()//определяем максимальное значение в потоке чисел
                .orElse(0);//если поток пуст, возвращаем 0

        for (Page page : pages) {//ищем страницу с максимальным количеством слов-ассоциаций
            if (page.getKeywords().size() == maxKeywords) {
                page.incrementVisits();
                System.out.println(page);
            }
        }
    }

    // 6. Страницы с совпадением чётности букв и слов
    public void pagesMatchingWordEvenness() {
        for (Page page : pages) {
            int wordCount = page.getKeywords().size();//количество слов-ассоциаций
            boolean allMatch = page.getKeywords().stream()
                    .allMatch(word -> (word.length() % 2) == (wordCount % 2));//проверяем выполняется ли заданное условие

            if (allMatch) {
                page.incrementVisits();//увеличиваем счетчик посещений страницы
                System.out.println(page);//выводим информацию о страницы
            }
        }
    }

    // 7. Первая страница с самым длинным словом
    public void pageWithLongestWord() {
        Page result = null;//переменная для объекта страница, на которой находится самое большое слово
        String longestWord = "";//переменная для хранения самого длинного слова

        for (Page page : pages) {
            for (String word : page.getKeywords()) {//перебираем каждое слово-ассоциацию для каждой страницы
                if (word.length() > longestWord.length()) {//ищем слово максимальной длинны и страницу, на которой оно находится
                    longestWord = word;
                    result = page;
                }
            }
        }

        if (result != null) {//если найдено самое длинное слово
            result.incrementVisits();//увеличиваем счетчик посещений на один
            System.out.println("Page: " + result.getTitle() + ", Longest Word: " + longestWord);
        }
    }

    // 8. Поиск самой подходящей страницы
    public void findMostRelevantPage(List<String> searchWords) {
        Page bestPage = null;//переменная для хранения самой подходящей страницы
        int maxMatches = 0;//переменная для хранения максимального количества совпадений слов-ассоциаций

        for (Page page : pages) {
            int matches = (int) page.getKeywords().stream()//создаем поток из слов-ассоциаций текущей страницы
                    .filter(searchWords::contains)//оставляем в потоке только те слова, которые есть в searchWords
                    .count();//считаем количество совпавших слов

            if (matches > maxMatches) {//обновляем максимум совпадений и страницу
                maxMatches = matches;
                bestPage = page;
            }
        }

        if (bestPage != null) {//если нашли подходящую страницу
            bestPage.incrementVisits();//увеличиваем счетчик посещений
            System.out.println("Most Relevant Page: " + bestPage.getTitle());
        }
    }


    // 9. Топ-3 самых посещаемых страниц
    public void topThreePages() {
        pages.stream()//создаем поток из коллекции pages
                .sorted(Comparator.comparingInt(Page::getVisits).reversed())//сортируем страницы по убыванию посещений
                .limit(3)//выбираем первые три элемента из отсортированного потока
                .forEach(page -> {//для каждой выбранной страницы
                    page.incrementVisits();//увеличиваем счетчик посещений
                    System.out.println(page);
                });
    }

    // 10. Поиск наименее подходящих страниц
    public void findLeastRelevantPages(List<String> searchWords) {
        int maxMismatch = -1;
        List<Page> leastRelevantPages = new ArrayList<>();

        for (Page page : pages) {
            int mismatches = (int) searchWords.stream()//создаем поток из слов searchWords
                    .filter(word -> !page.getKeywords().contains(word))//оставляем только те слова, которые не содержатся в словах-ассоциациях текущей старницы
                    .count();//считаем количество не совпавших слов

            if (mismatches > maxMismatch) {
                maxMismatch = mismatches;//обновляем minMismatch
                leastRelevantPages.clear();//отчищаем список
                leastRelevantPages.add(page);//добавляем текущую страницу
            } else if (mismatches == maxMismatch) {//если количество несовпадений равно текущему максимуму
                leastRelevantPages.add(page);//добавляем текущую страницу
            }
        }

        leastRelevantPages.forEach(System.out::println);//выводим список наименее релевантных страниц
    }
}

```

### 5. Анализ правильности решения

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на пустой массив:

    - **Input**:
        ```
        Введите N и M: 0 1
        ```

    - **Output**:
        ```
        Вы ввели пустой массив
        ```
        
    - **Input**:
        ```
        Введите N и M: 2 0
        ```

    - **Output**:
        ```
        Вы ввели пустой массив
        ```

2. Тест на массив с нечетным количеством элементов:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        1,2 2,3 3,4
        4,5 5,6 6,7
        7,8 8,9 9,1
        ```

    - **Output**:
        ```
        Медиана последовательности = 5.6
        от -10 до 0  от 0 до 10  
              0          9    
        Нормализованный массив:
        0,132 0,253 0,374 
        0,495 0,615 0,736 
        0,857 0,978 1,000 

        ```

3. Тест на массив с четным количеством элементов:

    - **Input**:
        ```
        Введите N и M: 2 2
        Введите элементы массива: 
        1,5 2,5
        3,5 4,5
        ```

    - **Output**:
        ```
        Медиана последовательности = 4.0
        от -10 до 0  от 0 до 10  
              0          4    
        Нормализованный массив:
        0,333 0,556 
        0,778 1,000 
        ```
4. Тест на массив с одинаковыми значениями среднего арифметического в двух столбцах:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        0,5 1,5 2,5
        3,5 4,5 5,5
        9,5 7,5 8,5

        ```

    - **Output**:
        ```
        Медиана последовательности = 4.5
        от -10 до 0  от 0 до 10  
              0          9    
        Нормализованный массив:
        0,158 0,053 0,263 
        0,474 0,368 0,579 
        0,789 1,000 0,895
        ```
5. Тест на массив с одинаковыми значениями среднего арифметического и дисперсии в двух столбцах:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        0,5 1,5 2,5
        2,5 1,5 0,5
        3,5 4,5 3,5
        ```

    - **Output**:
        ```
        Медиана последовательности = 2.5
        от -10 до 0  от 0 до 10  
              0          9    
        Нормализованный массив:
        0,111 0,556 0,333 
        0,556 0,111 0,333 
        0,778 0,778 1,000
        ```
6. Тест на массив с отрицательными числами:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        -1,0 -2,0 -3,0
        4,0 5,0 6,0
        -11,0 12,0 15,0
        ```

    - **Output**:
        ```
        Медиана последовательности = 4.0
        от -20 до -10  от -10 до 0  от 0 до 10  от 10 до 20  
              1            3            3            2      
        Нормализованный массив:
        0,385 0,346 0,308 
        0,577 0,615 0,654 
        0,000 0,885 1,000 

        ```
