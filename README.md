## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2401`

#### Выполнил: `Тараканов Владислав Алексеевич`

#### Вариант: `27`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Выбор структуры данных](#2-выбор-структуры-данных)
- [Алгоритм](#3-алгоритм)
- [Программа](#4-программа)
- [Анализ правильности решения](#5-анализ-правильности-решения)

### 1. Постановка задачи

Разработать программу для реализации системы поиска страниц по ключевым словам.
Каждая страница содержит название, массив слов-ассоциаций и счётчик посещений.
Реализовать функции добавления страниц, выполнения поиска, анализа данных и сортировки страниц по заданным критериям.

Данную задачу можно разделить подзадачи:
1.  Создадим класс страница, хранящий название страницы, список слов-ассоциаций и количество посещений.
2.  Создадим методы для работы со страницей, в том числе вывод в формате: название - количество посещений.
3.  Создадим класс для поиска, вывода и сортировки страниц.
4.  Организуем вывод списка страниц.
5.  Организуем добавление страницы
6.  Организуем вывод слов-ассоциаций нужной страницы.
7.  Организуем вывод списка страниц без слов для поиска.
8.  Организуем увелечение количества посещений для страниц с максимальным количеством слов-ассоциаций.
9.  Организуем увелечение количество посещений для страниц с совпадением четности букв и слов.
10. Организуем поиск и вывод первой страницы с самым длинным словом-ассоциацией.
11. Организуем поиск и увелечение счетчика посещений самой подходящей страницы для запроса.
12. Организуем поиск, вывод и увелечение счетчика посещений для 3-х самых посещаемых страниц.
13. Организуем поиск и вывод страниц наименее подходящих запросу.


### 2. Выбор структуры данных

|       | название переменной |  Тип (в Java)  | Применение      
|-------|---------------------|----------------|------------------------------------------------------
| Число | `title`             | `String`       |название страницы     
| Число | `keywords`          | `List<String>` |список слов-ассоциаций
| Число | `visits`            | `int`          |количество посещений|
| Число | `pages`             | `List<String>` | список всех страниц                
| Число | `maxKeywords`       | `int`          |максимальное количество слов-ассоциаций
| Число | `wordCount`         | `int`          |количество слов-ассоциаций текущей страницы
| Число | `allMatch`          | `boolean`      |соответствие условию четности
| Число | `result`            | `Page`         |страница с самым длинным словом-ассоциацией
| Число | `longestWord`       | `String`       |хранит самое длинное слово
| Число | `word`              | `String`       |перебор всех слов-ассоциаций
| Число | `searchWords`       | `List<String>` |массив для поиска нужной страницы(запрос)
| Массив| `bestPage`          | `Page`         |хранит самую подходящую страницу
| Массив| `maxMatches`        | `int`          |максимальное количество совпадений слов-ассоциаций
| Массив| `matches`           | `int`          |количество совпавших слов-ассоциаций
| Массив| `maxMismatch`       | `int`          |максимальное количество несовпадений
| Массив| `leastRelevantPages`| `List<String>` |список наименее подходящих страниц
| Массив| `mismatch`          | `int`          |количество несовпадений
| Массив| `word`              | `String`       |перебор слов

### 3. Алгоритм

#### Алгоритм выполнения программы:

1. **Класс Page**  
   Необходим для хранения информации о страницы в одном месте. Помогает ускорить работу по поиску и обработке данных и упрощает написание программы.
   Обеспечивает необходимые методы работы с данным классом. Позволяет отдельно получать имя страницы, количество посещений страницы, слова-ассоциации,
   а также увеличивать счетчик посещений и выводить страницу в формате: "название" - "количество посещений".
   
3. **Класс SearchSystem**  
   Используется для организации алгоритмов поиска, обработки и вывода данных о страницах. На борту имеет следующие методы:
     - **displayPages** 
       Вывод списка страниц в формате: "название - количество посещений"
     - **addPage** 
       Добавляет страницу с указанным названием и массивом слов-ассоциаций
     - **displayKeywords**
       Выводит массив слов-ассоциаций для страницы с указанным названием. Количество посещений страницы увеличивается.
     - **displayPagesWithoutKeywords**
       Отображает список страниц, у которых нет слов-ассоциаций для поиска. Увеличивает количество посещений для этих страниц.
     - **pagesWithMaxKeywords**
       Выводит список страниц с максимальным количеством слов-ассоциаций в порядке их добавления. Увеличивает количество посещений для
       каждой страницы в списке.
     - **pagesMatchingWordEvenness**
       Проверяет, есть ли в списке страницы, у которых количество букв в каждом словеассоциации совпадает по чётности с общим
       количеством слов. Увеличивает количество посещений для таких страниц.
     - **pageWithLongestWord**
       Находит и выводит первую страницу, содержащую самое длинное слово среди всех слов-ассоциаций, и это слово.
     - **findMostRelevantPage**
       По переданному массиву слов находит и возвращает страницу, которая больше всего подходит. Подходящей
       считается страница с максимальным количеством совпадений слов. Увеличивает количество посещений для найденной страницы.
     - **topThreePages**
       Выводит три самые посещаемые страницы. Если у нескольких страниц одинаковое количество посещений, выводятся первые
       по порядку добавления. Увеличивает количество посещений для этих страниц.
     - **findLeastRelevantPages**
       По переданному массиву слов находит страницы, которые наименее соответствуют массиву. Наименьшее соответствие
       определяется количеством слов, которые есть в одном массиве, но отсутствуют в другом. Возвращает список таких страниц.



### 4. Программа

```java
import java.util.*;

//создание класса Страница
class Page {
    String title;//название страницы
    List<String> keywords;// список слов-ассоциаций
    int visits;//количество просмотров страницы

    //создание конструктора для создания страницы
    public Page(String title, List<String> keywords,Integer visits) {
        this.title = title;
        this.keywords = new ArrayList<>(keywords);
        this.visits = visits;
    }

    //метод для получения имени страницы
    public String getTitle() {
        return title;
    }

    //метод для получения количества посещений страницы
    public int getVisits() {
        return visits;
    }

    //метод для получения слов-ассоциацией страницы
    public List<String> getKeywords() {
        return keywords;
    }

    //метод для увелечения количества посещений страницы на один
    public void incrementVisits() {
        visits++;
    }

    //метод для вывода имени страницы и количества посещений
    @Override
    public String toString() {
        return title + " - " + visits;
    }
}

//создания класса для поиска, вывода и сортировки страниц
class SearchSystem {
    private final List<Page> pages = new ArrayList<>();

    // 1. Вывод списка страниц
    public void displayPages() {
        for (Page page : pages) {
            System.out.println(page);
        }
    }

    // 2. Добавление страницы
    public void addPage(String title, List<String> keywords, Integer visits) {
        pages.add(new Page(title, keywords, visits));
    }

    // 3. Вывод слов-ассоциаций страницы, которую ищем
    public void displayKeywords(String title) {
        for (Page page : pages) {
            if (page.getTitle().equalsIgnoreCase(title)) {//поиск страницы с таким же названием
                page.incrementVisits();//когда нашли нужную страницу, увеличиваем счетчик посещений на один
                System.out.println(page.getKeywords());//выводим слова-ассоциации нужной страницы
                return;
            }
        }
        System.out.println("Page not found.");//Если не нашли страницу с нужным названием выводим, что страница не найдена
    }

    // 4. Вывод страниц без слов для поиска
    public void displayPagesWithoutKeywords() {
        for (Page page : pages) {
            if (page.getKeywords().isEmpty()) {//проверяем пустой ли список слов-ассоциаций
                page.incrementVisits();//увеличиваем счетчик посещений на один
                System.out.println(page);//выводим название страницы и количество посещений
            }
        }
    }

    // 5. Страницы с максимальным количеством слов-ассоциаций
    public void pagesWithMaxKeywords() {//находим максимальное количество слов-ассоциаций
        int maxKeywords = pages.stream()//создаем поток из коллекции pages
                .mapToInt(page -> page.getKeywords().size())//преобразуем каждую страницу в поток чисел,где каждое число количества слов-ассоциаций
                .max()//определяем максимальное значение в потоке чисел
                .orElse(0);//если поток пуст, возвращаем 0

        for (Page page : pages) {//ищем страницу с максимальным количеством слов-ассоциаций
            if (page.getKeywords().size() == maxKeywords) {
                page.incrementVisits();
                System.out.println(page);
            }
        }
    }

    // 6. Страницы с совпадением чётности букв и слов
    public void pagesMatchingWordEvenness() {
        for (Page page : pages) {
            int wordCount = page.getKeywords().size();//количество слов-ассоциаций
            boolean allMatch = page.getKeywords().stream()
                    .allMatch(word -> (word.length() % 2) == (wordCount % 2));//проверяем выполняется ли заданное условие

            if (allMatch) {
                page.incrementVisits();//увеличиваем счетчик посещений страницы
                System.out.println(page);//выводим информацию о страницы
            }
        }
    }

    // 7. Первая страница с самым длинным словом
    public void pageWithLongestWord() {
        Page result = null;//переменная для объекта страница, на которой находится самое большое слово
        String longestWord = "";//переменная для хранения самого длинного слова

        for (Page page : pages) {
            for (String word : page.getKeywords()) {//перебираем каждое слово-ассоциацию для каждой страницы
                if (word.length() > longestWord.length()) {//ищем слово максимальной длинны и страницу, на которой оно находится
                    longestWord = word;
                    result = page;
                }
            }
        }

        if (result != null) {//если найдено самое длинное слово
            result.incrementVisits();//увеличиваем счетчик посещений на один
            System.out.println("Page: " + result.getTitle() + ", Longest Word: " + longestWord);
        }
    }

    // 8. Поиск самой подходящей страницы
    public void findMostRelevantPage(List<String> searchWords) {
        Page bestPage = null;//переменная для хранения самой подходящей страницы
        int maxMatches = 0;//переменная для хранения максимального количества совпадений слов-ассоциаций

        for (Page page : pages) {
            int matches = (int) page.getKeywords().stream()//создаем поток из слов-ассоциаций текущей страницы
                    .filter(searchWords::contains)//оставляем в потоке только те слова, которые есть в searchWords
                    .count();//считаем количество совпавших слов

            if (matches > maxMatches) {//обновляем максимум совпадений и страницу
                maxMatches = matches;
                bestPage = page;
            }
        }

        if (bestPage != null) {//если нашли подходящую страницу
            bestPage.incrementVisits();//увеличиваем счетчик посещений
            System.out.println("Most Relevant Page: " + bestPage.getTitle());
        }
    }


    // 9. Топ-3 самых посещаемых страниц
    public void topThreePages() {
        pages.stream()//создаем поток из коллекции pages
                .sorted(Comparator.comparingInt(Page::getVisits).reversed())//сортируем страницы по убыванию посещений
                .limit(3)//выбираем первые три элемента из отсортированного потока
                .forEach(page -> {//для каждой выбранной страницы
                    page.incrementVisits();//увеличиваем счетчик посещений
                    System.out.println(page);
                });
    }

    // 10. Поиск наименее подходящих страниц
    public void findLeastRelevantPages(List<String> searchWords) {
        int maxMismatch = -1;
        List<Page> leastRelevantPages = new ArrayList<>();

        for (Page page : pages) {
            int mismatches = (int) searchWords.stream()//создаем поток из слов searchWords
                    .filter(word -> !page.getKeywords().contains(word))//оставляем только те слова, которые не содержатся в словах-ассоциациях текущей старницы
                    .count();//считаем количество не совпавших слов

            if (mismatches > maxMismatch) {
                maxMismatch = mismatches;//обновляем minMismatch
                leastRelevantPages.clear();//отчищаем список
                leastRelevantPages.add(page);//добавляем текущую страницу
            } else if (mismatches == maxMismatch) {//если количество несовпадений равно текущему максимуму
                leastRelevantPages.add(page);//добавляем текущую страницу
            }
        }

        leastRelevantPages.forEach(System.out::println);//выводим список наименее релевантных страниц
    }
}

```

### 5. Анализ правильности решения

1. Тест для displayPages:

    - 1.**Output**:
        ```
        Page1 - 2
        Page2 - 3
        Page3 - 0
        ```
        
    - 2.**Output**:
        ```
        Page1 - 2
        Page2 - 3
        Page3 - 0
        Page4 - 1
        ```

   2. Тест для displayKeywords:

    - 1.**Output**:
        ```
        [apple, banana, cherry]
        ```
        
    - 2.**Output**:
        ```
        Page not found.
        ```

3. Тест для displayPagesWithoutKeywords:

    - 1.**Output**:
        ```
       Page3 - 1
        ```
        
    - 2.**Output**:
        ```
        Page3 - 2
        Page5 - 1
        ```
4. Тест для pagesWithMaxKeywords:

    - 1.**Output**:
        ```
        Page1 - 3
        ```
        
    - 2.**Output**:
        ```
        Page1 - 4
        Page6 - 3
        ```
5. Тест для pagesMatchingWordEvenness:

    - 1.**Output**:
        ```
        Page2 - 4
        Page4 - 2
        ```
        
    - 2.**Output**:
        ```
        Page2 - 5
        Page4 - 3
        Page7 - 1
        ```
6. Тест для pageWithLongestWord:

    - 1.**Output**:
        ```
       Page: Page4, Longest Word: elephant
        ```
        
    - 2.**Output**:
        ```
        Page: Page8, Longest Word: watermelon
        ```
7. Тест для findMostRelevantPage:

    - 1.**Output**:
        ```
       Most Relevant Page: Page1
        ```
        
    - 2.**Output**:
        ```
       Most Relevant Page: Page6
        ```
8. Тест для topThreePages:

    - 1.**Output**:
        ```
        Page2 - 6
        Page1 - 6
        Page4 - 4
        ```
        
    - 2.**Output**:
        ```
       Page9 - 11
       Page2 - 7
       Page1 - 7
        ```
9. Тест для findLeastRelevantPages:

    - 1.**Output**:
        ```
        Page3 - 2
        ```
        
    - 2.**Output**:
        ```
        Page3 - 3
        Page5 - 2
        ```
